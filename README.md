# TinyBin Binary Protocol
<!-- START_SECTION:BADGES_SECTION -->
<a href="docs/img/badges.svg"><img src="docs/img/badges.svg" alt="Project Badges" title="Generated by badges package from github.com/cdvelop/devscripts"></a>
<!-- END_SECTION:BADGES_SECTION -->


Minimal binary serialization protocol for WebAssembly and TinyGo, following tinyreflect philosophy

## Why?

**Binary serialization in WebAssembly requires a different approach** than traditional server-side Go applications. Standard libraries create significant binary bloat that hurts web performance.

### The Problem
Go's standard library serialization packages are designed for server environments, not WebAssembly:

- üåê **WebAssembly performance** - Large binaries slow loading and hurt user experience
- üì¶ **Binary size bloat** - Standard packages add significant overhead
- üîÑ **TinyGo compatibility** - Many packages don't compile cleanly with TinyGo
- ‚ö° **Runtime overhead** - Heavy reflection and type introspection

### The Solution
TinyBin provides **ultra-minimal, focused binary serialization** that delivers:

- üèÜ **Dramatically smaller binaries** - Optimized for WebAssembly deployment
- ‚úÖ **Full TinyGo compatibility** - No compilation issues or warnings
- üéØ **Predictable performance** - No hidden allocations or overhead
- üîß **Minimal API** - Only essential operations for binary data handling
- üåç **Multilingual error handling** - Integrated with tinystring's error system
- ‚ôªÔ∏è **Maximum code reuse** - Leverages tinyreflect and tinystring infrastructure

### Supported Types (Minimalist Approach)
TinyBin **intentionally** supports only a minimal set of types to keep binary size small:

**‚úÖ Supported Types:**
- **Basic types**: `string`, `bool`
- **All numeric types**: `int8`, `int16`, `int32`, `int`, `int64`, `uint8`, `uint16`, `uint32`, `uint`, `uint64`, `float32`, `float64`
- **Slices**: `[]T` where T is any supported type
- **Arrays**: `[N]T` where T is any supported type
- **Structs**: Only with supported field types (no custom marshaling)
- **Pointers**: Only to supported types above

**‚ùå Unsupported Types:**
- `interface{}`, `chan`, `func`
- `complex64`, `complex128`
- `map[K]V` (replaced with slices for better performance)
- Custom marshaling interfaces
- Nested complex types beyond supported scope

This focused approach ensures minimal code size while covering the most common binary serialization needs.

## Quick Start

```go
import "github.com/cdvelop/tinybin"

// Define your data structure
type User struct {
    Name string
    Age  int
    Active bool
}

// Marshal to binary
user := User{Name: "Alice", Age: 30, Active: true}
data, err := tinybin.Marshal(user)
if err != nil {
    // handle error
}

// Unmarshal from binary
var user2 User
err = tinybin.Unmarshal(data, &user2)
if err != nil {
    // handle error
}
```

## Core API

### Primary Functions

#### `Marshal(v interface{}) ([]byte, error)`
Encodes any supported value into binary format.

```go
data, err := tinybin.Marshal(myStruct)
```

#### `Unmarshal(b []byte, v interface{}) error`
Decodes binary data into a pointer to a value.

```go
err := tinybin.Unmarshal(data, &myStruct)
```

#### `MarshalTo(v interface{}, dst io.Writer) error`
Encodes a value directly to an io.Writer.

```go
var buf bytes.Buffer
err := tinybin.MarshalTo(myStruct, &buf)
```

### Encoder Type

#### `NewEncoder(out io.Writer) *Encoder`
Creates a new encoder that writes to the specified output.

```go
encoder := tinybin.NewEncoder(&buffer)
```

#### `(*Encoder) Encode(v interface{}) error`
Encodes a value using the encoder.

```go
err := encoder.Encode(myStruct)
```

#### `(*Encoder) Reset(out io.Writer)`
Resets the encoder to write to a new output.

```go
encoder.Reset(newBuffer)
```

#### Writing Methods
- `(*Encoder) Write(p []byte)` - Write raw bytes
- `(*Encoder) WriteString(s string)` - Write a string with length prefix
- `(*Encoder) WriteVarint(v int64)` - Write variable-length integer
- `(*Encoder) WriteUvarint(v uint64)` - Write variable-length unsigned integer
- `(*Encoder) WriteUint16(v uint16)` - Write 16-bit unsigned integer
- `(*Encoder) WriteUint32(v uint32)` - Write 32-bit unsigned integer
- `(*Encoder) WriteUint64(v uint64)` - Write 64-bit unsigned integer
- `(*Encoder) WriteFloat32(v float32)` - Write 32-bit float
- `(*Encoder) WriteFloat64(v float64)` - Write 64-bit float

### Decoder Type

#### `NewDecoder(r io.Reader) *Decoder`
Creates a new decoder that reads from the specified input.

```go
decoder := tinybin.NewDecoder(bytes.NewReader(data))
```

#### `(*Decoder) Decode(v interface{}) error`
Decodes a value using the decoder.

```go
err := decoder.Decode(&myStruct)
```

#### Reading Methods
- `(*Decoder) Read(p []byte) (int, error)` - Read raw bytes
- `(*Decoder) ReadString() (string, error)` - Read a length-prefixed string
- `(*Decoder) ReadVarint() (int64, error)` - Read variable-length integer
- `(*Decoder) ReadUvarint() (uint64, error)` - Read variable-length unsigned integer
- `(*Decoder) ReadUint16() (uint16, error)` - Read 16-bit unsigned integer
- `(*Decoder) ReadUint32() (uint32, error)` - Read 32-bit unsigned integer
- `(*Decoder) ReadUint64() (uint64, error)` - Read 64-bit unsigned integer
- `(*Decoder) ReadFloat32() (float32, error)` - Read 32-bit float
- `(*Decoder) ReadFloat64() (float64, error)` - Read 64-bit float
- `(*Decoder) ReadBool() (bool, error)` - Read boolean value
- `(*Decoder) Slice(n int) ([]byte, error)` - Get slice of next n bytes

## Performance Features

### Pool-Based Reuse
TinyBin uses sync.Pool for encoder/decoder reuse, eliminating allocation overhead:

```go
// Encoders and decoders are automatically pooled
for i := 0; i < 1000; i++ {
    data, _ := tinybin.Marshal(myData)  // Uses pooled encoder
    tinybin.Unmarshal(data, &result)    // Uses pooled decoder
}
```

### Variable-Length Encoding
All integers use variable-length encoding (varint) for optimal space efficiency:

- Small values (0-127) use 1 byte
- Medium values use 2-4 bytes
- Large values use up to 8 bytes
- Strings are prefixed with their length

### Zero-Copy Operations
The decoder provides zero-copy slice operations when possible:

```go
// ReadSlice returns underlying data without copying
data, err := decoder.ReadSlice()
```

## WebAssembly Optimization

### Minimal Dependencies
TinyBin only depends on:
- `github.com/cdvelop/tinyreflect` - Lightweight reflection
- `github.com/cdvelop/tinystring` - Error handling and utilities
- Standard library: `unsafe`, `encoding/binary`, `io`, `bytes`, `sync`, `math`

### No Standard Library Bloat
**Prohibited packages** (not used in TinyBin):
- `fmt` - Use `tinystring.Fmt()` instead
- `strconv` - Use `tinystring.Convert()` instead
- `errors` - Use `tinystring.Err()` instead
- `strings` - Use `tinystring.Convert()` methods
- `reflect` - Replaced with `tinyreflect`

### TinyGo Compatibility
- ‚úÖ Compiles cleanly with TinyGo
- ‚úÖ No runtime panics or type assertion failures
- ‚úÖ Predictable memory usage
- ‚úÖ No hidden allocations

## Advanced Usage

### Custom Codec Interface
For extending TinyBin with custom types:

```go
type Codec interface {
    EncodeTo(*Encoder, tinyreflect.Value) error
    DecodeTo(*Decoder, tinyreflect.Value) error
}
```

### Struct Field Control
Control struct field serialization with `binary` tags:

```go
type MyStruct struct {
    PublicField  int    `binary:""`      // Included in serialization
    PrivateField int    `binary:"-"`     // Excluded from serialization
    CustomName   string `binary:"name"` // Field name becomes "name"
}
```

### Error Handling
All operations return errors instead of panicking:

```go
data, err := tinybin.Marshal(myData)
if err != nil {
    // Handle specific error conditions
    // Uses tinystring error system for multilingual support
}
```

## Migration from Standard Library

### From encoding/binary
```go
// Old way - requires reflect, larger binary
import "encoding/binary"

// New way - minimal, WebAssembly optimized
import "github.com/cdvelop/tinybin"

// Marshal with automatic type detection
data, err := tinybin.Marshal(myStruct)

// Unmarshal with type safety
err = tinybin.Unmarshal(data, &myStruct)
```

### Performance Comparison
- **Binary size**: Significantly smaller than standard library alternatives
- **Memory usage**: Predictable with pooled encoders/decoders
- **WebAssembly**: Optimized for browser deployment
- **TinyGo**: Full compatibility without compilation issues

## Best Practices

### 1. Use Pointers for Unmarshaling
Always pass pointers to Unmarshal:

```go
// ‚úÖ Correct
var result MyStruct
err := tinybin.Unmarshal(data, &result)

// ‚ùå Incorrect - will not work
var result MyStruct
err := tinybin.Unmarshal(data, result)
```

### 2. Reuse Encoders/Decoders
For high-performance scenarios:

```go
// ‚úÖ Efficient - uses pooling
for i := range items {
    data, _ := tinybin.Marshal(items[i])
    // process data
}

// ‚ùå Inefficient - creates new instances each time
for i := range items {
    encoder := tinybin.NewEncoder(&buffer)
    encoder.Encode(items[i])
}
```

### 3. Handle Errors Appropriately
```go
data, err := tinybin.Marshal(myData)
if err != nil {
    // Log error with context
    log.Printf("Failed to marshal data: %v", err)
    return err
}
```

### 4. Use Appropriate Data Structures
Prefer slices over maps for better performance:

```go
// ‚úÖ Better for WebAssembly
type DataList struct {
    Items []DataItem `binary:"items"`
}

type DataItem struct {
    Key   string `binary:"key"`
    Value int    `binary:"value"`
}

// ‚ùå Avoid maps (not supported)
type DataMap struct {
    Items map[string]int `binary:"items"` // Not supported
}
```

## Acknowledgements
This repository is an adaptation of the project [https://github.com/Kelindar/binary](https://github.com/Kelindar/binary), focusing on TinyGo as the compilation target.



## [Contributing](https://github.com/cdvelop/cdvelop/blob/main/CONTRIBUTING.md)

