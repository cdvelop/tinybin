# TinyBin Protocol Specification
<!-- START_SECTION:BADGES_SECTION -->
<a href="docs/img/badges.svg"><img src="docs/img/badges.svg" alt="Project Badges" title="Generated by badges package from github.com/cdvelop/devscripts"></a>
<!-- END_SECTION:BADGES_SECTION -->

TinyBin is a high-performance binary serialization library for Go, specifically designed for TinyGo compatibility. It's an adaptation of the [Kelindar/binary](https://github.com/Kelindar/binary) project, optimized for resource-constrained environments and embedded systems.

## Features

- **TinyGo Compatible**: Designed to work seamlessly with TinyGo compiler
- **High Performance**: Efficient binary encoding/decoding with minimal allocations
- **Type Safe**: Compile-time type checking with reflection-based runtime support
- **Extensible**: Custom codec support through the `Codec` interface
- **Memory Efficient**: Object pooling for encoders and decoders

## Installation

```bash
go get github.com/cdvelop/tinybin
```

## Quick Start

```go
package main

import (
    "fmt"
    "github.com/cdvelop/tinybin"
)

// Define a struct to serialize
type User struct {
    Name    string  `json:"name"`
    Age     int     `json:"age"`
    Active  bool    `json:"active"`
    Balance float64 `json:"balance"`
}

func main() {
    // Create an instance
    user := &User{
        Name:    "Alice",
        Age:     30,
        Active:  true,
        Balance: 123.45,
    }

    // Encode to binary
    data, err := tinybin.Encode(user)
    if err != nil {
        panic(err)
    }

    // Decode from binary
    var decoded User
    err = tinybin.Decode(data, &decoded)
    if err != nil {
        panic(err)
    }

    fmt.Printf("Decoded: %+v\n", decoded)
}
```

## Core API

### Encoding Functions

#### `Encode(v any) ([]byte, error)`
Encodes any value into binary format and returns the resulting bytes.

```go
data, err := tinybin.Encode(myStruct)
```

#### `EncodeTo(v any, dst io.Writer) error`
Encodes a value directly to an `io.Writer`.

```go
var buf bytes.Buffer
err := tinybin.EncodeTo(myStruct, &buf)
```

### Decoding Functions

#### `Decode(b []byte, v any) error`
Decodes binary data into a value. The destination must be a pointer.

```go
var result MyStruct
err := tinybin.Decode(data, &result)
```

### Encoder Type

#### `NewEncoder(out io.Writer) *Encoder`
Creates a new encoder that writes to the specified `io.Writer`.

```go
encoder := tinybin.NewEncoder(&buffer)
```

#### `(*Encoder) Encode(v any) error`
Encodes a value using the encoder instance.

```go
err := encoder.Encode(myValue)
```

#### `(*Encoder) Reset(out io.Writer)`
Resets the encoder to write to a different `io.Writer`.

```go
encoder.Reset(newBuffer)
```

#### `(*Encoder) Buffer() io.Writer`
Returns the underlying writer.

```go
writer := encoder.Buffer()
```

### Encoder Write Methods

The `Encoder` type provides methods for writing primitive types:

- `Write(p []byte)` - writes raw bytes
- `WriteVarint(v int64)` - writes a variable-length signed integer
- `WriteUvarint(x uint64)` - writes a variable-length unsigned integer
- `WriteUint16(v uint16)` - writes a 16-bit unsigned integer
- `WriteUint32(v uint32)` - writes a 32-bit unsigned integer
- `WriteUint64(v uint64)` - writes a 64-bit unsigned integer
- `WriteFloat32(v float32)` - writes a 32-bit floating point number
- `WriteFloat64(v float64)` - writes a 64-bit floating point number
- `WriteBool(v bool)` - writes a boolean value
- `WriteString(v string)` - writes a string with length prefix

### Decoder Type

#### `NewDecoder(r io.Reader) *Decoder`
Creates a new decoder that reads from the specified `io.Reader`.

```go
decoder := tinybin.NewDecoder(bytes.NewReader(data))
```

#### `(*Decoder) Decode(v any) error`
Decodes a value using the decoder instance. The destination must be a pointer.

```go
err := decoder.Decode(&result)
```

### Decoder Read Methods

The `Decoder` type provides methods for reading primitive types:

- `Read(b []byte) (int, error)` - reads raw bytes
- `ReadVarint() (int64, error)` - reads a variable-length signed integer
- `ReadUvarint() (uint64, error)` - reads a variable-length unsigned integer
- `ReadUint16() (uint16, error)` - reads a 16-bit unsigned integer
- `ReadUint32() (uint32, error)` - reads a 32-bit unsigned integer
- `ReadUint64() (uint64, error)` - reads a 64-bit unsigned integer
- `ReadFloat32() (float32, error)` - reads a 32-bit floating point number
- `ReadFloat64() (float64, error)` - reads a 64-bit floating point number
- `ReadBool() (bool, error)` - reads a boolean value
- `ReadString() (string, error)` - reads a length-prefixed string
- `Slice(n int) ([]byte, error)` - returns a slice of the next n bytes
- `ReadSlice() ([]byte, error)` - reads a variable-length byte slice

## Supported Data Types

TinyBin automatically handles encoding and decoding for the following types:

### Primitive Types
- `bool` - encoded as a single byte (0 or 1)
- `int`, `int8`, `int16`, `int32`, `int64` - variable-length encoded
- `uint`, `uint8`, `uint16`, `uint32`, `uint64` - variable-length encoded
- `float32`, `float64` - IEEE 754 binary representation
- `string` - UTF-8 bytes with length prefix

### Composite Types
- **Slices** - length-prefixed sequence of elements
  ```go
  []int{1, 2, 3, 4, 5}     // → [5, 1, 2, 3, 4, 5]
  []string{"a", "b", "c"}   // → [3, "a", "b", "c"]
  ```
- **Arrays** - fixed-size sequence of elements
  ```go
  [3]int{1, 2, 3}          // → [1, 2, 3]
  ```
- **Structs** - field-by-field encoding
  ```go
  type Point struct {
      X, Y int
  }
  ```
- **Pointers** - nil check followed by element encoding
  ```go
  var ptr *MyStruct = &MyStruct{...}  // → [0, ...data...]
  var nilPtr *MyStruct = nil          // → [1]
  ```

## Endianness

The library provides predefined endianness constants:

```go
tinybin.LittleEndian  // Little-endian byte order
tinybin.BigEndian     // Big-endian byte order
```

## Codec Interface

For custom types, implement the `Codec` interface:

```go
type Codec interface {
    EncodeTo(*Encoder, tinyreflect.Value) error
    DecodeTo(*Decoder, tinyreflect.Value) error
}
```

## Utility Functions

### `ToString(b *[]byte) string`
Converts a byte slice to string without allocation (unsafe operation).

### `ToBytes(v string) []byte`
Converts a string to byte slice without allocation (unsafe operation).

## Advanced Usage

### Custom Encoder/Decoder

```go
// Create custom encoder
var buf bytes.Buffer
encoder := tinybin.NewEncoder(&buf)

// Encode multiple values
err := encoder.Encode(value1)
err = encoder.Encode(value2)

// Create decoder
decoder := tinybin.NewDecoder(&buf)

// Decode values
err = decoder.Decode(&result1)
err = decoder.Decode(&result2)
```

### Error Handling

```go
data, err := tinybin.Encode(myValue)
if err != nil {
    // Handle encoding error
    log.Printf("Encoding failed: %v", err)
}

var result MyType
err = tinybin.Decode(data, &result)
if err != nil {
    // Handle decoding error
    log.Printf("Decoding failed: %v", err)
}
```

## Performance Considerations

- **Object Pooling**: Encoders and decoders are pooled for reuse
- **Zero Allocations**: Where possible, operations avoid heap allocations
- **Variable-Length Integers**: Integers are encoded with minimal bytes
- **Unsafe Operations**: String/byte conversions use unsafe operations for performance

## Dependencies

- [`github.com/cdvelop/tinyreflect`](https://github.com/cdvelop/tinyreflect) - Reflection utilities for TinyGo
- [`github.com/cdvelop/tinystring`](https://github.com/cdvelop/tinystring) - String utilities

## License

This project is an adaptation of [https://github.com/Kelindar/binary](https://github.com/Kelindar/binary) focused on TinyGo compilation targets.

---
## [Contributing](https://github.com/cdvelop/cdvelop/blob/main/CONTRIBUTING.md)