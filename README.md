# TinyBin Protocol Specification
<!-- START_SECTION:BADGES_SECTION -->
<a href="docs/img/badges.svg"><img src="docs/img/badges.svg" alt="Project Badges" title="Generated by badges.sh from github.com/cdvelop/devscripts"></a>
<!-- END_SECTION:BADGES_SECTION -->

**Version:** 1.0  
**Target:** Go fullstack applications with WebAssembly support  
**TinyGo Compatible:** Yes  

## 🚀 Implementation Status

### ✅ **Core Features - COMPLETED**
- ✅ **Protocol Header**: Binary format with version, type ID, and count
- ✅ **Struct Registration**: `AddStructs()` with StructID-based identification
- ✅ **StructID System**: Uses `tinyreflect.Type.StructID()` for unique type identification
- ✅ **Recursive Encoder**: Clean architecture supporting structs and slices
- ✅ **Slice Support**: Full encoding of `[]struct` types using tinyreflect
- ✅ **Nested Structs**: Support for structs containing struct slices
- ✅ **Primitive Types**: All basic types (int8-64, uint8-64, float32/64, bool, string)
- ✅ **LEB128 Varint**: Efficient variable integer encoding
- ✅ **TinyReflect Integration**: Extended with `Len()` and `Index()` methods

### ✅ **Encoder - COMPLETED**
- ✅ **Single Struct Encoding**: `struct` → binary
- ✅ **Slice Encoding**: `[]struct` → binary with count
- ✅ **Recursive Field Encoding**: Handles nested structs and slices
- ✅ **Type Safety**: Validates registered types before encoding
- ✅ **Binary Output**: Little-endian, streaming-compatible format

### 🔶 **Decoder - PARTIALLY IMPLEMENTED**
- ✅ **Protocol Parsing**: Header, type ID, and count extraction
- ✅ **Type Validation**: Verifies registered struct types
- ✅ **Slice Recognition**: Detects single vs. multiple struct scenarios
- ❌ **Actual Decoding**: Field reconstruction (tinyreflect limitations)
- ❌ **Struct Instantiation**: Creating and populating struct instances
- ❌ **Slice Reconstruction**: Building slice instances from binary data

### ❌ **Advanced Features - NOT IMPLEMENTED**
- ❌ **Cycle Detection**: Preventing recursive struct dependencies
- ❌ **Depth Limiting**: Stack overflow protection for deep nesting
- ❌ **Field Modification**: Direct struct field updates via tinyreflect
- ❌ **Binary Slices**: `[]byte` encoding/decoding
- ❌ **Primitive Slices**: `[]string`, `[]int32`, etc.
- ❌ **Error Recovery**: Partial decode on corruption
- ❌ **Schema Validation**: Runtime field count/type checking

### 🎯 **Current Capabilities**
**Encoding:** ✅ **Fully functional** - Encodes structs and slices to binary format  
**Decoding:** 🔶 **Placeholder** - Parses headers but doesn't reconstruct data  
**Testing:** ✅ **All tests pass** - Comprehensive test suite validates encoding  

### 🔧 **Next Steps for Full Implementation**
1. **Extend TinyReflect**: Add field modification capabilities (`SetField()`, `SetString()`, etc.)
2. **Implement Real Decoder**: Actual struct/slice reconstruction from binary data
3. **Add Cycle Detection**: Prevent infinite recursion during type registration
4. **Field Validation**: Runtime checking of struct field compatibility
5. **Binary/Slice Types**: Support for `[]byte` and primitive slice types  

## Overview

TinyBin is a binary data transfer protocol designed specifically for Go applications, with first-class support for WebAssembly and TinyGo compilation. The protocol focuses on transferring slices of structs with maximum efficiency and minimal overhead.

## Design Principles

- **Struct-only encoding**: Only supports `[]struct` and `struct` types
- **Index-based field encoding**: Fields are encoded by position, not name
- **Zero reflection overhead**: Uses cached struct analysis with `tinyreflect`
- **WebAssembly optimized**: Little-endian, streaming interface
- **TinyGo compatible**: No maps, minimal heap allocations
- **Strict validation**: Exact struct matching required

### Controlled Nesting & Recursion
- **Cycle Detection**: The protocol automatically detects and rejects cyclical dependencies during type registration (e.g., `type User struct { Friends []User }`). This prevents infinite loops and ensures program stability.
- **Depth Limit**: To prevent stack overflow errors in deeply nested structures, `tinybin` imposes a fixed depth limit (e.g., 8 levels) during the recursive analysis of structs. This is more than enough for typical API designs while providing a critical safety guarantee.

## Supported Data Types

- **Numeric**: `int8`, `int16`, `int32`, `int64`, `uint8`, `uint16`, `uint32`, `uint64`, `float32`, `float64`
- **Boolean**: `bool`
- **Text**: `string` (UTF-8 encoded)
- **Binary**: `[]byte`
- **Slices**: Slices of any supported primitive type (`[]string`, `[]int32`, etc.) and slices of registered structs (`[]MyStruct`) are supported.
- **Structs**: Nested structs are supported, subject to the depth limit.

## Wire Format

### Message Structure
```
[Protocol Header][Data Payload]
```

### Protocol Header (6 bytes + varint)
```
[1 byte: Major Version]
[1 byte: Minor Version]  
[4 bytes: Struct ID (Type ID)]
[varint: Struct Count]
```

### Struct Identifier (4 bytes)
El identificador de struct (o ID de Tipo) es un `uint32` que representa el tipo de struct principal que se está transfiriendo.

**Asignación de ID:**
- El ID de un struct corresponde al valor devuelto por `tinyreflect.Type.StructID()` que es único para cada tipo de struct.
- **Requisito Crítico**: Los mismos tipos de struct deben estar registrados en el cliente (WASM) y el servidor para que los StructID coincidan.

### Data Payload
```
[Struct 0][Struct 1]...[Struct N]
```

Each struct contains fields in declaration order:
```
[Field 0][Field 1]...[Field N]
```

### Field Encoding by Type

| Type | Encoding |
|------|----------|
| `int8` | 1 byte, little-endian |
| `int16` | 2 bytes, little-endian |
| `int32` | 4 bytes, little-endian |
| `int64` | 8 bytes, little-endian |
| `uint8` | 1 byte |
| `uint16` | 2 bytes, little-endian |
| `uint32` | 4 bytes, little-endian |
| `uint64` | 8 bytes, little-endian |
| `float32` | 4 bytes, IEEE 754, little-endian |
| `float64` | 8 bytes, IEEE 754, little-endian |
| `bool` | 1 byte (`0x00` = false, `0x01` = true) |
| `string` | `[varint length][UTF-8 bytes]` |
| `[]byte` | `[varint length][raw bytes]` |
| `slice`  | `[varint element_count][element_0]...[element_N]` |

**Note on Slices:** The encoding of elements within a slice relies on the cached schema. The protocol knows whether to expect a primitive type or a struct type and applies the correct deserialization logic without needing extra type markers in the payload. `nil` and empty slices are both encoded as a slice with `0` elements.

### Variable Integer Encoding (LEB128)

Uses Little Endian Base 128 (LEB128) encoding for:
- String/byte slice lengths
- Struct counts in header

**LEB128 Rules:**
- 7 bits of data per byte
- MSB = 1 indicates continuation
- MSB = 0 indicates final byte
- Maximum value: 2^32 (4GB limit)

## API Design

### Handler & Core Types
The protocol is managed through a `TinyBin` handler that encapsulates the configuration and the cached struct schemas. This design avoids global state and ensures that different handlers can coexist with different configurations.

```go

// Config [✔] holds configuration for a TinyBin handler.
type Config struct {
    MaxDepth int // [✔] Maximum nesting depth for struct analysis
}

// TinyBin [✔] is the main handler for encoding and decoding operations.
type TinyBin struct {
    stObjects []stObject // [✔] Internal cache of registered struct schemas
    *Config              // [✔] Pointer to configuration
}

// stObject holds the cached metadata for a single struct type.
type stObject struct {
    stID     uint16      // Unique ID (index in the stObjects slice)
    stName   string      // Struct name for debugging purposes
    stFields []stField   // Ordered list of field metadata
}

// stField holds the metadata for a single struct field.
type stField struct {
    name     string          // Field name
    typeKind tinystring.Kind // The kind of the field (int, string, slice, etc.) from tinyreflect
    // Additional fields for offsets, nested type IDs, etc.
}
```

### Primary API
The API is designed to be clear and robust, providing methods for configuration, registration, and data conversion.

```go

// New [✔] creates a new TinyBin handler with optional configuration.
// If no config is provided or config is nil, uses default values.
h := tinybin.New() // default MaxDepth = 8
h2 := tinybin.New(&tinybin.Config{MaxDepth: 10})

// Register struct types. The order of registration is critical [✔]
// and must be identical on both client and server.
err := h.AddStructs(User{}, Address{}, Product{})

// Encode a slice of structs to an io.Writer.
err := h.Encode(w, []User{...})

// Decode from an io.Reader into a new slice of structs.
// The result must be type-asserted.
decoded, err := h.Decode(r)
users := decoded.([]User)

// Encode a slice of structs directly to a byte slice.
bytes, typeID, err := h.EncodeToBytes([]Product{...})

// Decode from a byte slice into a provided slice pointer.
var products []Product
err := h.DecodeFromBytes(bytes, typeID, &products)
```

## File Structure

```
tinybin/
├── tinybin.go        ✅ Main API: New(), Option, TinyBin struct
├── register.go       ✅ AddStructs() with StructID-based registration
├── encoder.go        ✅ Recursive encoder: Encode(), EncodeToBytes()
├── decoder.go        🔶 Decoder stubs: Decode(), DecodeFromBytes() (parsing only)
├── types.go          ✅ stObject, stField definitions using uint32 StructID
├── varint.go         ✅ LEB128 implementation
├── README.md         ✅ Protocol documentation with status
├── tinybin_test.go   ✅ Comprehensive test suite (all passing)
├── debug_test.go     ✅ Debug utilities and validation tests
└── debug_slice_test.go ✅ Slice-specific debugging and validation
```

### 🔧 **Extended Dependencies**
```
tinyreflect/
├── ValueOf.go        ✅ Extended with Len() and Index() methods
├── TypeOf.go         ✅ Extended with SliceType definition
└── ...              ✅ Core tinyreflect functionality
```

## Error Handling

### Error Types

- **Version Mismatch**: Major version differences
- **Type Mismatch**: El ID de struct recibido no coincide con ningún tipo registrado.
- **Dependency Not Registered**: Un struct anidado o un struct dentro de un slice depende de un tipo que no fue registrado. El protocolo falla inmediatamente para garantizar que solo se procesen datos de tipos conocidos y validados.
- **Field Count Mismatch**: Different number of fields in struct
- **Field Type Mismatch**: Field type differs at specific index
- **Unsupported Type**: Non-primitive type encountered
- **Length Overflow**: String/byte slice exceeds 4GB limit
- **Corrupted Data**: Invalid varint or malformed data

### Error Behavior

- **Fail Fast**: First error aborts entire operation
- **Detailed Messages**: Include field names, indices, and expected vs actual types
- **Strict Validation**: Exact struct matching required between encoder and decoder

### Controlled Nesting & Recursion
- **Cycle Detection**: The protocol automatically detects and rejects cyclical dependencies during type registration (e.g., `type User struct { Friends []User }`). This prevents infinite loops and ensures program stability.
- **Depth Limit**: To prevent stack overflow errors in deeply nested structures, `tinybin` imposes a fixed depth limit (e.g., 8 levels) during the recursive analysis of structs. This is more than enough for typical API designs while providing a critical safety guarantee.

## Version Compatibility

### Semantic Versioning
- **Major Version** (1 byte): Breaking changes, incompatible formats
- **Minor Version** (1 byte): Compatible additions, backwards compatible

### Compatibility Rules
- **Strict Compatibility**: Major version must match exactly
- **Minor Differences**: Encoder/decoder warn but continue processing
- **Forward Compatibility**: Not supported, exact version matching preferred

## Performance Optimizations

### Memory Management
- **Global Struct Cache**: Reuse analyzed struct metadata
- **Precalculated Offsets**: Avoid reflection during encoding/decoding
- **Stack Allocation**: Minimize heap allocations where possible
- **Buffer Reuse**: Encoder/decoder instances reuse internal buffers

### WebAssembly Specific
- **Little-Endian Native**: No byte order conversion overhead
- **Streaming Interface**: Memory-efficient for large datasets
- **TinyGo Compatible**: No unsupported reflection features

## Typical Usage Pattern

The following example demonstrates a more realistic usage pattern in a typical application, where `tinybin` is initialized once and shared.

### 1. Centralized Registration (`registry/registry.go`)
First, create a central package to define your data structures and initialize the `tinybin` handler. This ensures all parts of your application (server and client) use the exact same configuration.

```go
package registry

import "github.com/cdvelop/tinybin"

// Define structs used across the application.
type User struct {
    ID   uint64
    Name string
}

type Product struct {
    SKU   string
    Price float64
}

// H is the global, pre-configured TinyBin handler for the entire application.
var H *tinybin.TinyBin

func init() {
    // Initialize the handler once when the package is first used.
    H = tinybin.New()

    // Register all application structs in a specific, consistent order.
    // This order MUST be the same for the server and the WASM client.
    err := H.AddStructs(User{}, Product{})
    if err != nil {
        // A failure here is critical and should stop the application.
        panic("fatal error: failed to register structs with tinybin: " + err.Error())
    }
}
```

### 2. Usage in Application Code (`server/handlers.go`)
Now, other packages can import the `registry` and use the pre-configured handler to encode or decode data without needing to know the implementation details.

```go
package server

import (
    "bytes"
    "net/http"
    . "github.com/cdvelop/tinystring" // Import tinystring for string/error handling
    "my-app/registry" // Import the central registry
)

// apiHandler uses the shared tinybin handler to send binary data.
func apiHandler(w http.ResponseWriter, r *http.Request) {
    users := []registry.User{
        {ID: 1, Name: "Alice"},
        {ID: 2, Name: "Bob"},
    }

    // Use the pre-configured handler from the registry package.
    encodedBytes, _, err := registry.H.EncodeToBytes(users)
    if err != nil {
        http.Error(w,T(D.Encoding,D.Failed), http.StatusInternalServerError)
        return
    }

    w.Header().Set("Content-Type", "application/octet-stream")
    w.Write(encodedBytes)
    println("Sent encoded user data.")
}
```

### WebAssembly Integration
The WASM client would also import the `registry` package. Since the `init()` function is executed automatically, the `registry.H` handler will be available and configured identically to the server, ensuring perfect compatibility.

```go
//go:build wasm
// +build wasm

package main

import (
    "syscall/js"
    "my-app/registry" // Import the same registry
)

var h = registry.H // Use the shared, pre-configured handler

// ... rest of the WASM integration code ...
```

## Current Limitations

### ✅ **Resolved**
- ✅ **Struct Registration**: Now uses proper StructID from tinyreflect
- ✅ **Recursive Encoding**: Clean architecture without code duplication
- ✅ **Slice Support**: Full support for `[]struct` encoding
- ✅ **TinyReflect Integration**: Extended with slice iteration capabilities

### ❌ **Active Limitations**
1. **Incomplete Decoder**: Decoder only parses headers, doesn't reconstruct structs
2. **No Field Modification**: TinyReflect lacks struct field setting capabilities  
3. **No Maps**: Maps are not supported due to TinyGo compatibility
4. **No Interfaces**: Only concrete struct types are supported
5. **No Pointers**: Direct pointer encoding is not supported
6. **Limited Binary Types**: `[]byte` encoding not yet implemented
7. **No Primitive Slices**: `[]string`, `[]int32`, etc. not yet supported
8. **Missing Safety Features**:
    - **No Cycle Detection**: Recursive struct definitions not validated
    - **No Depth Limiting**: No protection against deep nesting
    - **No Schema Validation**: Runtime field compatibility not checked
9. **Field Order Dependency**: Adding, removing, or reordering fields breaks compatibility
10. **Manual Registration Order**: Developer must ensure identical registration order

### 🔧 **Architectural Notes**
- **Encoding**: Fully functional recursive implementation using pure tinyreflect
- **Decoding**: Requires extending tinyreflect with field modification methods
- **Testing**: All current functionality validated with comprehensive test suite

## Development Environment

- **Platform**: Debian 12 (Bookworm)
- **Go Version**: Compatible with standard Go and TinyGo
- **Dependencies**: `github.com/cdvelop/tinyreflect`, `github.com/cdvelop/tinystring`
- **Testing**: Unit tests for all encoding/decoding scenarios

## Security Considerations

- **Input Validation**: All inputs validated before processing
- **Buffer Overflow Protection**: Length limits enforced
- **Type Safety**: Strict type checking prevents data confusion
- **No Code Execution**: Pure data protocol, no executable content

## Future Considerations

- **Compression**: Optional compression for large payloads
- **Checksums**: Optional data integrity verification
- **Batch Operations**: Multi-struct-type encoding in single message
- **Schema Evolution**: Controlled field addition/removal strategies

---

**TinyBin Protocol v1.0** - Optimized for Go fullstack applications with WebAssembly support.



