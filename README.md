# TinyBin Protocol Specification
<!-- START_SECTION:BADGES_SECTION -->
<a href="docs/img/badges.svg"><img src="docs/img/badges.svg" alt="Project Badges" title="Generated by badges.sh from github.com/cdvelop/devscripts"></a>
<!-- END_SECTION:BADGES_SECTION -->

**Version:** 1.0  
**Target:** Go fullstack applications with WebAssembly support  
**TinyGo Compatible:** Yes  

## Overview

TinyBin is a binary data transfer protocol designed specifically for Go applications, with first-class support for WebAssembly and TinyGo compilation. The protocol focuses on transferring slices of structs with maximum efficiency and minimal overhead.

## Design Principles

- **Struct-only encoding**: Only supports `[]struct` and `struct` types
- **Index-based field encoding**: Fields are encoded by position, not name
- **Zero reflection overhead**: Uses cached struct analysis with `tinyreflect`
- **WebAssembly optimized**: Little-endian, streaming interface
- **TinyGo compatible**: No maps, minimal heap allocations
- **Strict validation**: Exact struct matching required

### Controlled Nesting & Recursion
- **Cycle Detection**: The protocol automatically detects and rejects cyclical dependencies during type registration (e.g., `type User struct { Friends []User }`). This prevents infinite loops and ensures program stability.
- **Depth Limit**: To prevent stack overflow errors in deeply nested structures, `tinybin` imposes a fixed depth limit (e.g., 8 levels) during the recursive analysis of structs. This is more than enough for typical API designs while providing a critical safety guarantee.

## Supported Data Types

- **Numeric**: `int8`, `int16`, `int32`, `int64`, `uint8`, `uint16`, `uint32`, `uint64`, `float32`, `float64`
- **Boolean**: `bool`
- **Text**: `string` (UTF-8 encoded)
- **Binary**: `[]byte`
- **Slices**: Slices of any supported primitive type (`[]string`, `[]int32`, etc.) and slices of registered structs (`[]MyStruct`) are supported.
- **Structs**: Nested structs are supported, subject to the depth limit.

## Wire Format

### Message Structure
```
[Protocol Header][Data Payload]
```

### Protocol Header (5 bytes + varint)
```
[1 byte: Major Version]
[1 byte: Minor Version]  
[2 bytes: Struct ID (Type ID)]
[varint: Struct Count]
```

### Struct Identifier (2 bytes)
El identificador de struct (o ID de Tipo) es un `uint16` que representa el tipo de struct principal que se está transfiriendo.

**Asignación de ID:**
- El ID de un struct corresponde a su índice en el slice de caché global `stObjects` después del registro.
- **Requisito Crítico**: El orden de registro con `h.AddStructs()` debe ser **idéntico** en el cliente (WASM) y el servidor. La falta de sincronización en el orden resultará en errores de decodificación.

### Data Payload
```
[Struct 0][Struct 1]...[Struct N]
```

Each struct contains fields in declaration order:
```
[Field 0][Field 1]...[Field N]
```

### Field Encoding by Type

| Type | Encoding |
|------|----------|
| `int8` | 1 byte, little-endian |
| `int16` | 2 bytes, little-endian |
| `int32` | 4 bytes, little-endian |
| `int64` | 8 bytes, little-endian |
| `uint8` | 1 byte |
| `uint16` | 2 bytes, little-endian |
| `uint32` | 4 bytes, little-endian |
| `uint64` | 8 bytes, little-endian |
| `float32` | 4 bytes, IEEE 754, little-endian |
| `float64` | 8 bytes, IEEE 754, little-endian |
| `bool` | 1 byte (`0x00` = false, `0x01` = true) |
| `string` | `[varint length][UTF-8 bytes]` |
| `[]byte` | `[varint length][raw bytes]` |
| `slice`  | `[varint element_count][element_0]...[element_N]` |

**Note on Slices:** The encoding of elements within a slice relies on the cached schema. The protocol knows whether to expect a primitive type or a struct type and applies the correct deserialization logic without needing extra type markers in the payload. `nil` and empty slices are both encoded as a slice with `0` elements.

### Variable Integer Encoding (LEB128)

Uses Little Endian Base 128 (LEB128) encoding for:
- String/byte slice lengths
- Struct counts in header

**LEB128 Rules:**
- 7 bits of data per byte
- MSB = 1 indicates continuation
- MSB = 0 indicates final byte
- Maximum value: 2^32 (4GB limit)

## API Design

### Handler & Core Types
The protocol is managed through a `TinyBin` handler that encapsulates the configuration and the cached struct schemas. This design avoids global state and ensures that different handlers can coexist with different configurations.

```go

// Config [✔] holds configuration for a TinyBin handler.
type Config struct {
    MaxDepth int // [✔] Maximum nesting depth for struct analysis
}

// TinyBin [✔] is the main handler for encoding and decoding operations.
type TinyBin struct {
    stObjects []stObject // [✔] Internal cache of registered struct schemas
    *Config              // [✔] Pointer to configuration
}

// stObject holds the cached metadata for a single struct type.
type stObject struct {
    stID     uint16      // Unique ID (index in the stObjects slice)
    stName   string      // Struct name for debugging purposes
    stFields []stField   // Ordered list of field metadata
}

// stField holds the metadata for a single struct field.
type stField struct {
    name     string          // Field name
    typeKind tinystring.Kind // The kind of the field (int, string, slice, etc.) from tinyreflect
    // Additional fields for offsets, nested type IDs, etc.
}
```

### Primary API
The API is designed to be clear and robust, providing methods for configuration, registration, and data conversion.

```go

// New [✔] creates a new TinyBin handler with optional configuration.
// If no config is provided or config is nil, uses default values.
h := tinybin.New() // default MaxDepth = 8
h2 := tinybin.New(&tinybin.Config{MaxDepth: 10})

// Register struct types. The order of registration is critical [✔]
// and must be identical on both client and server.
err := h.AddStructs(User{}, Address{}, Product{})

// Encode a slice of structs to an io.Writer.
err := h.Encode(w, []User{...})

// Decode from an io.Reader into a new slice of structs.
// The result must be type-asserted.
decoded, err := h.Decode(r)
users := decoded.([]User)

// Encode a slice of structs directly to a byte slice.
bytes, typeID, err := h.EncodeToBytes([]Product{...})

// Decode from a byte slice into a provided slice pointer.
var products []Product
err := h.DecodeFromBytes(bytes, typeID, &products)
```

## File Structure

```
tinybin/
├── tinybin.go        // Main API: New(), Option, TinyBin struct
├── register.go       // AddStructs() and the recursive analysis logic
├── encoder.go        // Encode(), EncodeToBytes()
├── decoder.go        // Decode(), DecodeFromBytes()
├── types.go          // stObject, stField type definitions
├── varint.go         // LEB128 implementation
└── README.md         // Protocol documentation
```

## Error Handling

### Error Types

- **Version Mismatch**: Major version differences
- **Type Mismatch**: El ID de struct recibido no coincide con ningún tipo registrado.
- **Dependency Not Registered**: Un struct anidado o un struct dentro de un slice depende de un tipo que no fue registrado. El protocolo falla inmediatamente para garantizar que solo se procesen datos de tipos conocidos y validados.
- **Field Count Mismatch**: Different number of fields in struct
- **Field Type Mismatch**: Field type differs at specific index
- **Unsupported Type**: Non-primitive type encountered
- **Length Overflow**: String/byte slice exceeds 4GB limit
- **Corrupted Data**: Invalid varint or malformed data

### Error Behavior

- **Fail Fast**: First error aborts entire operation
- **Detailed Messages**: Include field names, indices, and expected vs actual types
- **Strict Validation**: Exact struct matching required between encoder and decoder

### Controlled Nesting & Recursion
- **Cycle Detection**: The protocol automatically detects and rejects cyclical dependencies during type registration (e.g., `type User struct { Friends []User }`). This prevents infinite loops and ensures program stability.
- **Depth Limit**: To prevent stack overflow errors in deeply nested structures, `tinybin` imposes a fixed depth limit (e.g., 8 levels) during the recursive analysis of structs. This is more than enough for typical API designs while providing a critical safety guarantee.

## Version Compatibility

### Semantic Versioning
- **Major Version** (1 byte): Breaking changes, incompatible formats
- **Minor Version** (1 byte): Compatible additions, backwards compatible

### Compatibility Rules
- **Strict Compatibility**: Major version must match exactly
- **Minor Differences**: Encoder/decoder warn but continue processing
- **Forward Compatibility**: Not supported, exact version matching preferred

## Performance Optimizations

### Memory Management
- **Global Struct Cache**: Reuse analyzed struct metadata
- **Precalculated Offsets**: Avoid reflection during encoding/decoding
- **Stack Allocation**: Minimize heap allocations where possible
- **Buffer Reuse**: Encoder/decoder instances reuse internal buffers

### WebAssembly Specific
- **Little-Endian Native**: No byte order conversion overhead
- **Streaming Interface**: Memory-efficient for large datasets
- **TinyGo Compatible**: No unsupported reflection features

## Typical Usage Pattern

The following example demonstrates a more realistic usage pattern in a typical application, where `tinybin` is initialized once and shared.

### 1. Centralized Registration (`registry/registry.go`)
First, create a central package to define your data structures and initialize the `tinybin` handler. This ensures all parts of your application (server and client) use the exact same configuration.

```go
package registry

import "github.com/cdvelop/tinybin"

// Define structs used across the application.
type User struct {
    ID   uint64
    Name string
}

type Product struct {
    SKU   string
    Price float64
}

// H is the global, pre-configured TinyBin handler for the entire application.
var H *tinybin.TinyBin

func init() {
    // Initialize the handler once when the package is first used.
    H = tinybin.New()

    // Register all application structs in a specific, consistent order.
    // This order MUST be the same for the server and the WASM client.
    err := H.AddStructs(User{}, Product{})
    if err != nil {
        // A failure here is critical and should stop the application.
        panic("fatal error: failed to register structs with tinybin: " + err.Error())
    }
}
```

### 2. Usage in Application Code (`server/handlers.go`)
Now, other packages can import the `registry` and use the pre-configured handler to encode or decode data without needing to know the implementation details.

```go
package server

import (
    "bytes"
    "net/http"
    . "github.com/cdvelop/tinystring" // Import tinystring for string/error handling
    "my-app/registry" // Import the central registry
)

// apiHandler uses the shared tinybin handler to send binary data.
func apiHandler(w http.ResponseWriter, r *http.Request) {
    users := []registry.User{
        {ID: 1, Name: "Alice"},
        {ID: 2, Name: "Bob"},
    }

    // Use the pre-configured handler from the registry package.
    encodedBytes, _, err := registry.H.EncodeToBytes(users)
    if err != nil {
        http.Error(w,T(D.Encoding,D.Failed), http.StatusInternalServerError)
        return
    }

    w.Header().Set("Content-Type", "application/octet-stream")
    w.Write(encodedBytes)
    println("Sent encoded user data.")
}
```

### WebAssembly Integration
The WASM client would also import the `registry` package. Since the `init()` function is executed automatically, the `registry.H` handler will be available and configured identically to the server, ensuring perfect compatibility.

```go
//go:build wasm
// +build wasm

package main

import (
    "syscall/js"
    "my-app/registry" // Import the same registry
)

var h = registry.H // Use the shared, pre-configured handler

// ... rest of the WASM integration code ...
```

## Limitations

1. **No Maps**: Maps are not supported due to TinyGo compatibility.
2. **No Interfaces**: Only concrete struct types are supported.
3. **No Pointers**: Direct pointer encoding is not supported.
4. **Nesting Constraints**:
    - **Depth Limit**: Struct nesting is limited to a fixed depth to ensure stability.
    - **No Cycles**: Recursive struct definitions that create cycles are forbidden and will cause an error.
5. **Field Order Dependency**: Adding, removing, or reordering fields in a struct is a breaking change.
6. **Manual Registration Order**: The developer is responsible for ensuring that the order of struct registration with `h.AddStructs()` is identical on both the encoding and decoding ends.

## Development Environment

- **Platform**: Debian 12 (Bookworm)
- **Go Version**: Compatible with standard Go and TinyGo
- **Dependencies**: `github.com/cdvelop/tinyreflect`, `github.com/cdvelop/tinystring`
- **Testing**: Unit tests for all encoding/decoding scenarios

## Security Considerations

- **Input Validation**: All inputs validated before processing
- **Buffer Overflow Protection**: Length limits enforced
- **Type Safety**: Strict type checking prevents data confusion
- **No Code Execution**: Pure data protocol, no executable content

## Future Considerations

- **Compression**: Optional compression for large payloads
- **Checksums**: Optional data integrity verification
- **Batch Operations**: Multi-struct-type encoding in single message
- **Schema Evolution**: Controlled field addition/removal strategies

---

**TinyBin Protocol v1.0** - Optimized for Go fullstack applications with WebAssembly support.



